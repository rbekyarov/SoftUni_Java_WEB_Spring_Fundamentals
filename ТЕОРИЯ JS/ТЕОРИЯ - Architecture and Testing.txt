Множество притеснения – части от приложението извършват действия в различни домейни (напр. DB извиквания, бизнес логика, потребителски интерфейс)
Това води до високо свързване:
Ниското ниво на абстракция ограничава размера на приложението
Трудно е да смените един модул, без да засегнете останалите
Стъпките на кода се повтарят поради необходимост
Непрактично е повторното използване на модул в други приложения
Разработчикът трябва да е наясно с всички специфики на всеки модул

Ограничете единица код (функция, модул) до един домейн
Например метод, който само визуализира (изобразява) данни на екрана
Изпълнението е абстрахирано от детайлите
Например функцията за изобразяване не се занимава с източника на данните
Разработчикът не трябва да знае как модулът работи вътрешно, за да го използва
Повторното използване на кода е вторичен ефект – по-лесното разсъждение е основно

Често срещани стъпки:
Извличане на действия над различни домейни в техните собствени функции
Идентифицирайте подобни действия в различни части на приложението
Увеличете абстракцията на извлечените функции, така че да могат да се използват на повече места с минимални промени
Преместете функции от един домейн в отделен модул
Не прекалявайте с абстракцията! Добро правило – увеличете абстракцията, когато трябва да преработите кода


Isolated Modules


Backend API – специфичен за използваната услуга
Логика на заявката – специфична за бизнес логиката на приложението
Манипулиране на данни – специфично за бизнес логиката на приложението
UI дисплей и контрол
Полезни функции

Types of Tests:
Единични тестове – обхващат отделна функционалност
Например, тествайте резултата от функция с различен вход
Интеграционни тестове – обхващат комуникацията вътре и между цели модули
Например, тествайте дали данните, идващи от отдалечена заявка, се интерпретират правилно от бизнес логиката
Тестове от край до край (функционални) – покриват всички стъпки, които се случват, когато потребителят извърши действие, от потребителския интерфейс до базата данни и обратно

Unit Tests Usage
Единичните тестове се използват, за да се провери дали дадена част от кода (функция, клас и т.н.) работи правилно
Тестваният код не включва външни зависимости (състояние на приложението, други модули, външни системи)
Те са бързи за писане и бързи за изпълнение
Обикновено се създава от разработчика, който е наясно със спецификите на кода (тестване в бяла кутия)
Обичайните инструменти включват Mocha, Chai, QUnit, Jasmine и др.

Integration Tests Usage
Интеграционните тестове се използват за проверка на комуникацията между множество кодови елементи (функции, класове, цели модули)
Те често изискват включване на външни зависимости (други приложни модули, бази данни, отдалечени ресурси)
Сравнително сложно за създаване (поради външните зависимости)
Може да бъде делегиран на отделен екип, който не участва в писането на кода (тестване в черна кутия)
Често срещаните инструменти включват Sinon, JMock, Mockito и др.

End-to-End (Functional) Tests Usage
Функционалните тестове се използват за преминаване през цялото приложение в реална среда
Обикновено включва целия технологичен стек (REST услуги, операции с бази данни, удостоверяване и т.н.)
В зависимост от очаквания резултат и използваните инструменти, тяхната сложност е сравнима с интеграционните тестове
Най-вече грижата на специализираните инженери по автоматизация на QA
Обичайните инструменти включват Selenium, Puppeteer, Cypress и др.


What is Playwright?
Пълен пакет за тестване на уеб приложения в реална среда – уеб браузъра
Нашето приложение се изпълнява в браузър без headless
Въведеното от потребителя се симулира и резултатът се следи
Съвместим с Chromium, Firefox и WebKit
Предлага се в JavaScript, TypeScript, Python, C# и Java

npm install --save-dev playwright-chromium 

const { chromium } = require('playwright-chromium');
(async () => {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  await page.goto('https://google.com/');
  await page.screenshot({ path: `example.png` });
  await browser.close();
})();


Combine with a test-running framework (e.g., Mocha and Chai

const { chromium } = require('playwright-chromium');
const { expect } = require('chai');
let browser, page; // Declare reusable variables
describe('E2E tests', function() {
  before(async () => { browser = await chromium.launch(); });
  after(async () => { await browser.close(); });
  beforeEach(async () => { page = await browser.newPage(); });
  afterEach(async () => { await page.close(); }); 
